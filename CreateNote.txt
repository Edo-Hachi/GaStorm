#ビューポートサイズ取得
screen_size = get_viewport_rect().size


#シーン切替え
func _on_BtnStart_button_down() -> void:
	print("btn Push")
	get_tree().change_scene("res://Src/GamePlay.tscn")


#-----------------------------------------------------------------------------------
#ポーズ処理
https://qiita.com/2dgames_jp/items/3df03851d8e7a4622e40
	if Input.is_action_pressed("Pause"):
		#メインノードをpause
		get_tree().paused = true
		#ダイアログ表示　ダイアログだけはイベントを昼得るように設定(PauseMode = Process)
		$DlgPause.show_modal(true)　

#-----------------------------------------------------------------------------------
#ポーズダイアログを閉じた時の処理
func _on_DlgPause_tree_exited() -> void:
	if get_owner() != null:
		get_tree().paused = false


#以下ダイアログ側の処理
func _on_Button_pressed() -> void:
	get_tree().paused = false
	hide()


#-----------------------------------------------------------------------------------
#ノード配置は以下の通り

＋DlgPause（←これが小さいとボタン押せなかったりするので注意）
　＋ColorRect
　　＋　Button(Pause)
　　


#物理演算とかが終わったあとに安全にオブジェクトのコライダーをオフにする
$CollisionShape2D.set_deferred("disabled", true)
#$CollisionShape2D.disabled = true


#-----------------------------------------------------------------------------------
#目標座標まで勝手に移動するやつ
	position = position.move_toward(Vector2(0,0), delta * speed)


#-----------------------------------------------------------------------------------
#フィールド座標でのYソート

ワールド（Node2D）に所属する茂みなどのフィールドオブジェクトに自動的にYソートを付加し、
コライダーにしたがってキャラクタの表示順序を自動でソートし直してくれる。
メッチャ便利

https://www.youtube.com/watch?v=UfKMgHbaGow&list=PL9FzW-m48fn2SlrW0KoLT4n5egNdX-W9a&index=4
12；29



#-----------------------------------------------------------------------------------
#マウスをおっかけるとかはこれ
  var angle = get_angle_to(get_global_mouse_position())
  velocity.x = cos(angle)
  velocity.y = sin(angle)

  global_position += velocity * speed * delta

　ホーミングミサイルとかならこれでよいかも



#-----------------------------------------------------------------------------------
#親シーンを取得する
これで自分を生成した親のオブジェクトにアクセスできる　
	var p = find_parent("GameMain_Node2D")
	p.set_erase_enemy(999)　　#親の set_erase_enemy()関数にアクセス

ていうか一個上ならget_parent()で良かったorz


#-----------------------------------------------------------------------------------

ルートからの位置がわかっているなら孫からでも次のようにしてアクセスできる(ノードツリー内に限る)
	var aa= get_node("/root/GameMain_Node2D")
	aa.set_erase_enemy(999)

GameMain_Node2D.gd

func set_erase_enemy(var id):
	print("set_erase_enemy hoge ",id)


#-----------------------------------------------------------------------------------
#インスタンスIDとインスタンスIDからオブジェクトを検索する方法
#あんましつかえんかも
生成したインスタンスを変数に保存しといてそのままシーンなりノードで使うのが一番楽

var foo = "bar"
func _ready():
    var id = get_instance_id()
    var inst = instance_from_id(id)
    print(inst.foo) # Prints bar



#-----------------------------------------------------------------------------------
#wrapf(数値, 下限値, 上限値)とは

数値が下限値から上限値の間で変動。下限値より下がると上限値になり、上限値を越えると下限値になる。
wrapfのこの性質を利用して、今回はプレイヤーのｘ座標とy座標を画面のｘｙ座標内で変動させることで画面の反対から現れる動きを作っています


#-----------------------------------------------------------------------------------
#クラスを使ったリストの作り方
var EnemyMatrix = []
enum EnemyState {STAT_LOOP, STAT_PROC, STAT_ATAK, STAT_DEAD}

class ENEMY_MANAGE:
	var position : Vector2
	var state : int
	var lastpos : Vector2


func _ready() -> void:
	
	var eman = ENEMY_MANAGE.new()
	eman.position.x = 10
	eman.position.y = 64
	eman.lastpos.x = 128
	eman.lastpos.y = 128
	eman.state = EnemyState.STAT_LOOP

	EnemyMatrix.append(eman)

	var geteman : ENEMY_MANAGE
	print(EnemyMatrix[0].state)


#-----------------------------------------------------------------------------------
#クラスを無理やり2次元配列で静的宣言する
class EnemyData:
	var StartPos : Vector2
	var EndPos : Vector2
	var Speed : int = 0

var EnemyMatrix = []

func _ready() -> void:
	
	var DmyItem = EnemyData.new()
	
	for i in range(0, 8):
		EnemyMatrix.append([DmyItem,DmyItem,DmyItem,DmyItem,DmyItem,DmyItem,DmyItem,DmyItem])
	
	#あくまでも2次元配列で領域確保しただけなので、後で実データでちゃんと上書きしとかないとダメ

	var NewItem = EnemyData.new()
	EnemyMatrix[1][0] = NewItem

	NewItem = EnemyData.new()
	EnemyMatrix[1][1] = NewItem

	NewItem = EnemyData.new()
	EnemyMatrix[7][7] = NewItem
		
	for j in range(0,8):
		for i in range(0,8):
			print(i,"/",j,":",EnemyMatrix[i][j])

#-----------------------------------------------------------------------------------
#配列サイズ取得
EnemyList.size()


#-----------------------------------------------------------------------------------
新規に生成したクラスをListに辞書を関連付けして登録する方法
https://www.youtube.com/watch?v=jvhWbEIZWjo

#-----------------------------------------------------------------------------------
#パーティクル
https://www.youtube.com/c/PlayWithFurcifer
https://www.youtube.com/watch?v=F1Fyj3Lh_Pc
	
https://github.com/PlayWithFurcifer/godot-particle-systems-guide.git

#レイキャストによる直線視界のチェック、レーザーの発射

https://www.youtube.com/watch?v=ajk4RcR0R4g
この方はたくさんチュートリアル動画あげてくださってる



#スプリングジョイント2D説明
https://www.youtube.com/watch?v=p6HaqSVbkUw
バネでオブジェクト接続してバインバインさせられる
あとスライド、ピン固定もある
たとえば、跳び箱のジャンプ台みたいなバネ効果のあるオブジェクトを生成できる

#スケルタルアニメーション
https://docs.godotengine.org/ja/stable/tutorials/animation/cutout_animation.html#doc-cutout-animation
https://docs.godotengine.org/ja/stable/tutorials/animation/2d_skeletons.html
公式動画
https://www.youtube.com/watch?v=Cqp3PJQIrUc

#レイキャストによる、向きのチェック
https://kidscancode-org.translate.goog/blog/2018/03/godot3_visibility_raycasts/?_x_tr_sch=http&_x_tr_sl=en&_x_tr_tl=ja&_x_tr_hl=en&_x_tr_pto=wapp

#シェーダーによる背景あにめ
波の表現など
https://www.youtube.com/watch?v=xoyk_A0RSpI
https://www.youtube.com/watch?v=U91nqeUe1qQ

ラスタースクロールとかもこれでできそう


#戦闘スプライトをしっぽが追いかけるデモ
ホーミングレーザーとかつかえる
https://www.youtube.com/watch?v=v1iFfCq3_Ao


#10分でトップダウンシューティングを作るチュートリアル
https://www.youtube.com/watch?v=HycyFNQfqI0


#タイマについて(ていうか、色々とTipsが入っているのでしっかり中身をチェックしたい。スプライトのパーティクル破壊なんかもこの動画でやってる)
https://www.youtube.com/watch?v=n505BEFqPnw

get_tree().create_timer()だけで色々良いらしい


var timer
timer = get_tree().create_timer(3, false) #falseにしないとポーズした時に止まってくれない
yield(timer , "timeout")

これでタイムアウトを待てば良いらしい

#ヴァンパイアサバイバーを数10行で書こうってネタ
https://www.youtube.com/watch?v=LgvLbahJOTA


#スピード調整曲線係数
x += (TargetX - x) / n

nを変えるとxがTargetXに近づくにつれゆっくりとTargetX値に近づくようになる
ただし、最終的に極端に遅くなるのでどこかのしきい値を超えたらx = TargetXしてやる必要がある
if abs(x - TargetX) < 0.5 then
  x = TargetS
みたいな感じ

